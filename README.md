# java大作业文档

## 游戏设定和规则

大体上还是按照魔兽的思路来做.按照我们之前的讨论,我们的棋盘假设是$r$行$c$列.考虑到是对抗性的,我们不妨令左边是红军的司令部,右边是蓝军的司令部,两军相向而行.每个武士只能沿着当前行前进,玩家可以在每个回合开始之前在它的司令部生成一些武士,放在相应的行上,之后就是一些自动的逻辑了.

以下规则修改自原魔兽世界,可以作为我们的每一行的行动逻辑.

魔兽世界的西面是红魔军的司令部，东面是蓝魔军的司令部。两个司令部之间是依次排列的若干城市，城市从西向东依次编号为1,2,3 .... N ( N <= 20)。红魔军的司令部算作编号为0的城市，蓝魔军的司令部算作编号为N+1的城市。司令部有生命元，用于制造武士。

两军的司令部都会制造武士。武士一共有dragon 、ninja、lion、wolf 四种。每种武士都有编号、生命值、攻击力这三种属性。


双方的武士编号都是从1开始计算。红方制造出来的第n 个武士，编号就是n。同样，蓝方制造出来的第n 个武士，编号也是n。

武士在刚降生的时候有一个初始的生命值，生命值在战斗中会发生变化，如果生命值减少到0（生命值变为负数时应当做变为0处理），则武士死亡（消失）。

武士可以拥有武器。武器有三种，sword, bomb,和arrow，种类编号分别为0,1,2。

武器各有特点:

- sword武器的初始攻击力为拥有它的武士的攻击力的20%（去尾取整）。但是sword每经过一次战斗(不论是主动攻击还是反击)，就会变钝，攻击力变为本次战斗前的80% (去尾取整)。sword攻击力变为0时，视为武士失去了sword。如果武士降生时得到了一个初始攻击力为0的sword，则视为武士没有sword.
- 拥有bomb的武士，在战斗开始前如果判断自己将被杀死（不论主动攻击敌人，或者被敌人主动攻击都可能导致自己被杀死，而且假设武士可以知道敌人的攻击力和生命值），那么就会使用bomb和敌人同归于尽。武士不预测对方是否会使用bomb。
- arrow的攻击力是使用者当前攻击力的30%(去尾取整)。如果下一步要走到的城市有敌人，那么拥有arrow的武士就会放箭攻击下一个城市的敌人。arrow使用3次后即被耗尽，武士失去arrow。两个相邻的武士可能同时放箭把对方射死。

武士降生后就朝对方司令部走，在经过的城市如果遇到敌人（同一时刻每个城市最多只可能有1个蓝武士和一个红武士），就会发生战斗。战斗的规则是：

1. 在奇数编号城市，红武士先发起攻击
2. 在偶数编号城市，蓝武士先发起攻击
3. 先发起攻击的武士调用attack函数,然后后发起攻击的武士再调用fightback函数
6. 有可能由于武士自身攻击力太低，而导致武器攻击力为0。攻击力为0的武器也要使用。如果战斗中双方的生命值和武器的状态都不再发生变化，则战斗结束，算平局。
7. 战斗的胜方获得对方手里的武器。但是只能获得自己出生时所获得的武器.
8. 如果战斗开始前双方都没有武器，则战斗视为平局。如果先攻击方没有武器，则由后攻击方攻击。

不同的武士有不同的特点:

0. 所有武士战斗胜利之后都可以缴获对方武器,所谓缴获就是说如果对方的武器比我的好,那么我会丢掉自己的武器然后捡起对方的武器.
1. dragon不能拥有武器,dragon的战斗方式是dracarys(高等瓦雷利亚语),每场战斗胜利之后,攻击力加2,平局或者失败,攻击力减2.
2. ninja可以拥有两件武器。编号为n的ninjia降生时即获得编号为n%3 和(n+1)%3的武器。ninja 使用bomb不会让自己受伤。
4. 编号为n的lion降生时即获得编号为n%3 的武器。但是,lion 有“忠诚度”这个属性，其初始值等于它降生之后其司令部剩余生命元的数目。每前进一步忠诚度就降低K。忠诚度降至0或0以下，则该lion逃离战场,永远消失。但是已经到达敌人司令部的lion不会逃跑。lion在己方司令部可能逃跑。
5. wolf降生时没有武器，但是在战斗中如果获胜，就会缴获敌人的武器。(wolf 优点在于它的生命值会比较高).

以下是一个周期内的各个事件:

1.读入制造武士的请求,并制造,放置武士
2.所有武士前进一步狮子逃跑
3.城市产生生命元
4.如果某个城市只有一个武士,该武士获得生命元
5.放箭
6.评估是否需要使用炸弹,如果需要,那就用
7.战斗
8.胜者获得装备,生命元,检查武器,平局的话,双方只检查武器


武士到达对方司令部后就算完成任务了，从此就呆在那里无所事事。
任何一方的司令部里若是出现了敌人，则认为该司令部已被敌人占领。
任何一方的司令部被敌人占领，则战争结束。战争结束之后就不会发生任何事情了。
给定一个时间，要求你将从0点0分开始到此时间为止的所有事件按顺序输出。事件及其对应的输出样例如下：

## 实现

### 规定
- 左边是红军的司令部,右边是蓝军的司令部
- 红军的color为0,蓝军的color为1.
- 棋盘大小6行10列
- int的低16位存放红军的棋子编号,int的高16位存放蓝军的棋子编号,注意在右移的时候不能带符号右移
- 武器有三种，sword, bomb,和arrow，种类编号分别为0,1,2。
- dragon 、ninja、lion、wolf种类分别是0,1,2,3

### WarftMap

绝大多数涉及Chess(也就是武士)之间的相互作用的动作都需要有这个类参与.简单介绍一下这个类的成员变量:
- `private int[][] smap` 这个二位数组存放的是棋盘各个格子上红军武士和蓝军武士的id,其中低16位放红军id,高16位放蓝军id 
- `private int [][] LifeElements` 这个二维数组存放的是各个城市的生命元数量
- `private Map<Integer,Chess> Red_Armies` 存放的是红军的各个武士
- `private Map<Integer,Chess> Blue_Armies` 存放的是蓝军的各个武士
- `private int energy_r` 存放的是红军司令部的生命元
- `private int energy_b` 存放的是蓝军司令部的生命元
函数如下:
- `WarftMap()` 无参构造函数:初始化前述变量.
- `public void addLifeElements(int x,int y,int value)` 给坐标为(x,y)的城市增加value个生命元
- `public int getLifeElements(int x,int y)` 返回坐标为(x,y)的城市的生命元
- `public void setLifeElements(int x,int y,int value)`将坐标为(x,y)的城市的生命元设置为value
- `public int setChess`把_chess武士放到指定的位置,这个函数会修改二维数组和Red_Armies/Blue_Armies里面的实例属性,如果ifMarch为真,代表是往前进了一步,考虑到lion的忠诚度会改变,所以会调用这个对象的MarchEffect函数,除Lion以外,什么事情也不会发生
- `public int getChessId(int x, int y, int color)`返回坐标为(x,y),颜色为color的武士的id
- `public void removeChess` 将二维数组中的那个元素删掉
- `public void march(int x,int y,int color)` 让坐标为(x,y),颜色为color的武士按照红蓝双方各自的方向前进一步
- `public Chess getChess` 返回指定颜色和id的Chess
- `public Chess getChess(int x,int y,int color)`返回指定坐标指定颜色的Chess

武士之间攻击,反击;判定战斗是否胜利,武士缴获武器,武士获得城市的生命元,武士逃跑,处理死了的武士,需要由这个类调度.
要修改一个武士的属性,先将其从Red_Armies或者Blue_Armies中取出来,
再调用对应的接口函数修改属性
然后将Red_Armies或者Blue_Armies中原有的实例删掉
最后把改过属性的实例放回去

### Chess

Chess 的变量都比较简单,下面简单说一说各个函数都干了什么:
- `public void move(int _x,int _y)` 这个函数只是修改本对象的坐标而已,不影响棋盘
- `public Chess attack(Chess opponent)` 如果有sword的话,这个函数会调用自身武器的`use`函数,`use`函数会记录这个武器的使用次数,按照规则进行钝化等等,返回值是这个武器的伤害值,然后被攻击者调用`injured`函数,受到攻击,最后返回被攻击者.dragon由于只能通过dracarys造成伤害所以覆盖了这个函数
- `public Chess fightBack(Chess opponent)` 实现就是attack.Ninja 不会反击,覆盖了这个函数
- `public void injured(int attack)` 受到伤害值为attack的伤害,会更新自己的生命元数和存活状态
- `public void captureWeapon(Chess opponent)` 这个函数只是缴获敌人和我都有,但是敌人的比我好的武器,Lion,Ninja,Wolf都覆盖了这个函数
- `public void checkWeapons()` 战斗结束之后,检查武器,更新武器的使用情况,还有就是武器的伤害值
- `public int GainLifeElements(int all)`获胜之后获得所属城市的生命元,参数是该城市所累积的生命元,返回值是武士补满自己的生命元之后还剩的生命元
- `public int AfterWin(Chess opponent,int all)` 封装了赢了之后要干的事情,缴获武器,获取生命元,检查武器,由于dragon还会有攻击力上的改变,所以dragon覆盖了这个函数
- `public Chess UseBomb(Chess opponent)` 使用bomb,双方都死亡,返回对手的对象.Ninja覆盖
- `public void MarchEffect()` 前进会产生的副作用,在这里什么都不做.lion覆盖,狮子的忠诚度会降低
- `public int getAttackHarm()`返回attack函数将给对方造成的伤害,dragon覆盖了这一函数,dragon的伤害值不是来自武器
- `getFightBackHarm()` 返回fightback函数将给对方造成的伤害,Ninja覆盖了一函数,因为Ninja从不反击
- `public boolean willDie(Chess opponent)` 预测自己是否会死于对手刀下,方便判断是否要使用炸弹同归于尽
- `public Chess shoot(Chess opponent)` 朝对手射箭,返回中箭后的对手的对象

其余的子类覆盖了的函数均已做了说明,故不再赘述.

### Weapon
- `use` 函数会返回一个伤害值,然后会钝化,会改写使用次数,用完了就设置avail为false.我们确保一次战斗之前,武士手中有的武器都是available的.这点可以通过调用checkWeapon实现

### 一个周期的流程
1.读入制造武士的请求,并制造,放置武士
2.所有武士前进一步狮子逃跑
3.城市产生生命元
4.如果某个城市只有一个武士,该武士获得生命元
5.放箭
6.评估是否需要使用炸弹,如果需要,那就用
7.战斗
8.胜者获得装备,生命元,检查武器,平局的话,双方只检查武器
