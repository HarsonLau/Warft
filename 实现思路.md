# 实现思路

## 规定
- 左边是红军的司令部,右边是蓝军的司令部
- 红军的color为0,蓝军的color为1.
- 棋盘大小6行10列
- int的低16位存放红军的棋子编号,int的高16位存放蓝军的棋子编号,注意在右移的时候不能带符号右移


## 主函数的运行

主函数是`Warft`中的`main`函数,`run`函数作为`main`函数的循环体.run`函数中做这些事情:
1. 如果是第一次循环的话,需要初始化地图,时间,以及双方司令部.如果不是第一次循环的话,需要改时间
2. 分别去读红方和蓝方的`Request` ,然后创建棋子.
3. 将这些棋子部署到地图上的相应坐标
4. 遍历每个棋子,根据时间进行特殊操作.
5. 遍历每个棋子,调用`attack`函数,然后在攻击函数中使用武器的`use`函数进行攻击,不管是否死亡都会进行攻击,如果死亡就修改`live`标记
6. 对于死亡的棋子,需要将其从`Red_Armies`和`Blue_Armies`中去掉,还需要将其从地图中去掉
7. 活着的棋子向前移动
8. 移动之后,判断是否胜利.

## `Warft`类的属性
- private
    1. WarftMap类型的地图allMap,这个类型中含有一个二维数组,放置棋子,获取棋子,删除棋子的方法.
    2. 计时器preTime
    3. 两个阵营生成新棋子的请求列表
    4. 给新棋子分配的id
    5. 阵营的生命元
- public:
    1. main函数
    2. run函数
    3. 插入请求的函数
    
## WarftMap类的属性

- private:
    1. 一个二维int数组.int的低16位存放红军的棋子编号,int的高16位存放蓝军的棋子编号,注意在右移的时候不能带符号右移.
    2. 两个阵营的所有棋子
- public:
    1. 放置棋子函数
    2. 获取棋子函数
    3. 删除棋子函数 

## Timer类
- private:
    1. hours 
    2. mins
- public
    1. 设置时间的接口
    2. 返回小时数
    3. 返回分钟数
    4. 时间增加

## Chess类
- protected:
    1.出生时间
    2.出生
- public:
    1. id
    2. 种类
    3. 攻击力
    4. 防御
    5. 现有生命元
    6. 最大生命元
    7. 横纵坐标
    8. 阵营,也就是颜色
    9. 武器数组
    10. 存活标记
    11. 移动到某处的函数
    12. 攻击函数
    13. 手上函数
    14. 缴获武器
    
## Weapon类
-protected:
    1. 主人
    2. 类型
    3. id
    4. 使用武器的函数

## Request类
-public:
    1. 横坐标
    2. 种类
    
## 如何将一个棋子放到另一个坐标
修改一个棋子的坐标涉及到这个棋子对象本身内部的坐标值,棋盘上那个二维数组中的值.
这个动作由棋盘完成,先检查二位数组的值,修改二维数组的值,然后再在hashmap中取出相应的棋子,修改它的值,将原来的值覆盖掉.
如果将要移动到的位置有活的武士,返回1.

## 武士前进如何操作
由于左边是红军司令部,右边是蓝军司令部,所以说红军的武士从右边开始移动,蓝军的武士从左边开始移动.
移动的话,棋盘调用remove,把当前位置的棋子id置为0,再由棋盘调用setChess函数,把它放到正确的位置上.

## 武器的use函数
根据规则改变武器使用次数

## 攻击如何实现
要实现攻击的话,关键是要修改地图里面各个武士的生命值.这必须涉及地图类.
取出两个攻击的对象,然后攻击者调用attack函数,attack函数调用武器的use函数,然后返回一个攻击力值.
然后地图再用这个攻击力值调用被攻击者的injured函数,使得被攻击者受伤.
然后将这两个对象放回Red_Armies,Blue_Armies中.



